<script>
    /**
     * Media Studio Engine 
     * Unified Capture & Slicing Suite
     */

    class MediaStudio {
        constructor() {
            this.state = {
                // Media Source
                media: null,        // Original Image or Video object
                mediaType: null,    // 'image' | 'video'
                mediaUrl: null,

                // Studio Context
                workflow: 'idle',   // 'idle' | 'capture' | 'studio'
                mode: 'grid',       // 'grid' | 'island'

                // Layout State
                fitMode: true,
                zoom: 1,

                // Slicing Parameters
                rows: 1,
                cols: 4,
                offsetX: 0,
                offsetY: 0,
                frameW: 0,          // 0 = Auto
                frameH: 0,
                spacingX: 0,
                spacingY: 0,
                threshold: 50,
                anchor: 'center',

                // Animation State
                frames: [],
                activeFrameIdx: 0,
                isPlaying: false,

                // Adjustment State
                adjustments: {
                    brightness: 0,
                    contrast: 0,
                    saturation: 0,
                    rotation: 0,
                    flipH: false,
                    flipV: false,
                    removeBg: false
                }
            };

            this.timers = {
                refresh: null,
                capture: null
            };

            this.initElements();
            this.initEvents();
            this.startPipLoop();
        }

        initElements() {
            this.els = {
                // Layout
                layout: document.querySelector('.studio-layout'),
                sidebar: id('unified-sidebar'),
                main: id('studio-main'),
                dropzone: id('studio-dropzone'),

                // Inputs
                videoInput: id('video-input'),
                spriteInput: id('sprite-input'),

                // Sidebar Packs
                capturePack: id('capture-settings-pack'),
                studioPack: id('studio-core-pack'),
                adjustPack: id('studio-adjustments-pack'),
                exportPack: id('export-pack'),

                // Interactive Viewport
                canvasContainer: id('canvas-container'),
                canvasWrapper: id('studio-canvas-wrapper'),
                videoPreview: id('video-preview-el'),
                imagePreview: id('image-preview-el'),
                spritePreview: id('sprite-preview'), // For capture results
                sourceCanvas: id('source-canvas'),    // Primary Studio canvas
                overlayCanvas: id('overlay-layer'),

                // HUD / Controls
                zoomBtn: id('zoom-toggle-btn'),
                zoomSlider: id('zoom-slider'),
                zoomVal: id('zoom-val'),
                pipContainer: id('pip-container'),
                pipCanvas: id('pip-canvas'),
                progress: id('sprite-progress'),

                // Capture Params
                strideSlider: id('frame-interval'),
                strideNum: id('stride-val'),
                capScaleSlider: id('sprite-output-scale'),
                capScaleNum: id('sprite-scale-val'),
                generateBtn: id('generate-sprite-btn'),

                // Studio Params
                gridCols: id('grid-columns'),
                colLabel: id('col-val'),
                gridRows: id('grid-rows'),
                rowLabel: id('row-val'),
                frameCountSlider: id('frame-count-slider'),
                frameCountVal: id('frame-count-val'),
                offX: id('grid-offset-x'),
                offXLabel: id('offx-val'),
                offY: id('grid-offset-y'),
                offYLabel: id('offy-val'),
                modeGridBtn: id('mode-grid-btn'),
                modeIslandBtn: id('mode-island-btn'),
                gridControls: id('grid-controls'),
                islandControls: id('island-controls'),
                thresholdSlider: id('island-threshold'),
                thresholdLabel: id('thresh-val'),

                // Adjustments
                anchorSelect: id('normalize-anchor'),
                removeBgToggle: id('remove-bg-toggle'),
                previewBgBtn: id('preview-bg-btn'),
                brightnessSlider: id('brightness-slider'),
                brightnessVal: id('brightness-val'),
                contrastSlider: id('contrast-slider'),
                contrastVal: id('contrast-val'),
                saturationSlider: id('saturation-slider'),
                saturationVal: id('satur-val'),
                rotateBtn: id('rotate-90'),
                flipHBtn: id('flip-h'),
                flipVBtn: id('flip-v'),
                filterGrayscale: id('filter-grayscale'),
                filterInvert: id('filter-invert'),

                // Studio Params Extra
                autoDetectBtn: id('auto-detect-btn'),

                // Export
                exportFormat: id('sprite-format'),
                exportQuality: id('sprite-quality'),
                bgMethodSelector: id('bg-method-selector'),
                bgRemovalMethod: id('bg-removal-method'),
                colorPickerInput: id('color-picker-input'),
                chromaTolerance: id('chroma-tolerance'),
                chromaToleranceVal: id('chroma-tolerance-val'),
                alphaThreshold: id('alpha-threshold'),
                alphaThresholdVal: id('alpha-threshold-val'),
                chromaR: id('chroma-r'),
                chromaG: id('chroma-g'),
                chromaB: id('chroma-b'),
                downloadBtn: id('download-sprite-btn')
            };

            // Helpers
            function id(name) { return document.getElementById(name); }
        }

        initEvents() {
            // Media Hub - Unified Upload
            if (this.els.videoInput) this.els.videoInput.onchange = (e) => this.handleFile(e.target.files[0]);
            if (this.els.spriteInput) this.els.spriteInput.onchange = (e) => this.handleFile(e.target.files[0]);

            // Re-upload by clicking dropzone or workspace background
            if (this.els.dropzone) this.els.dropzone.onclick = () => this.els.videoInput.click();
            if (this.els.canvasContainer) {
                this.els.canvasContainer.onclick = (e) => {
                    if (e.target === this.els.canvasContainer || e.target === this.els.canvasWrapper) {
                        this.els.videoInput.click();
                    }
                };
            }

            // Mode Switching (Grid/Island)
            if (this.els.modeGridBtn) this.els.modeGridBtn.onclick = () => this.setStudioMode('grid');
            if (this.els.modeIslandBtn) this.els.modeIslandBtn.onclick = () => this.setStudioMode('island');

            // Capture Params Sync
            this.sync(this.els.strideSlider, this.els.strideNum, 'stride');
            this.sync(this.els.capScaleSlider, this.els.capScaleNum, 'captureScale');

            // Grid Params Sync
            this.sync(this.els.gridCols, this.els.colLabel, 'cols');
            this.sync(this.els.gridRows, this.els.rowLabel, 'rows');
            this.sync(this.els.offX, this.els.offXLabel, 'offsetX');
            this.sync(this.els.offY, this.els.offYLabel, 'offsetY');

            if (this.els.frameCountSlider) {
                this.els.frameCountSlider.oninput = (e) => {
                    this.state.frameCount = parseInt(e.target.value);
                    if (this.els.frameCountVal) this.els.frameCountVal.value = e.target.value;
                };
            }
            if (this.els.frameCountVal) {
                this.els.frameCountVal.oninput = (e) => {
                    const val = parseInt(e.target.value) || 0;
                    this.state.frameCount = val;
                    if (this.els.frameCountSlider) this.els.frameCountSlider.value = val;
                };
            }

            if (this.els.thresholdSlider) {
                this.els.thresholdSlider.oninput = (e) => {
                    this.state.threshold = parseInt(e.target.value);
                    if (this.els.thresholdLabel) this.els.thresholdLabel.value = e.target.value;
                    this.refresh();
                };
            }

            // Adjustment Events
            if (this.els.removeBgToggle) {
                this.els.removeBgToggle.onchange = (e) => {
                    this.state.adjustments.removeBg = e.target.checked;
                    if (this.els.previewBgBtn) this.els.previewBgBtn.disabled = !e.target.checked;

                    // Show/hide method selector
                    if (this.els.bgMethodSelector) {
                        this.els.bgMethodSelector.style.display = e.target.checked ? 'block' : 'none';
                    }

                    this.applyImageAdjustments();
                };
            }

            if (this.els.previewBgBtn) {
                this.els.previewBgBtn.onclick = () => {
                    // Toggle preview mode
                    this.state.previewBgRemoval = !this.state.previewBgRemoval;
                    this.els.previewBgBtn.textContent = this.state.previewBgRemoval ?
                        'ðŸ‘ï¸ Hide Preview' : 'ðŸ‘ï¸ Live Removal Preview';
                    this.applyImageAdjustments();
                };
            }

            // Background Removal Method selector
            if (this.els.bgRemovalMethod) {
                this.els.bgRemovalMethod.onchange = (e) => {
                    const method = e.target.value;
                    const chromaPicker = document.getElementById('chroma-color-picker');
                    const alphaControl = document.getElementById('alpha-threshold-control');

                    if (chromaPicker) chromaPicker.style.display = (method === 'chroma') ? 'block' : 'none';
                    if (alphaControl) alphaControl.style.display = (method === 'alpha') ? 'block' : 'none';

                    this.applyImageAdjustments();
                };
            }

            // Sync BG Removal Sliders
            this.sync(this.els.chromaTolerance, this.els.chromaToleranceVal, 'chromaTolerance', true);
            this.sync(this.els.alphaThreshold, this.els.alphaThresholdVal, 'alphaThreshold', true);

            if (this.els.colorPickerInput) {
                this.els.colorPickerInput.oninput = (e) => {
                    const hex = e.target.value;
                    if (this.els.chromaR && this.els.chromaG && this.els.chromaB) {
                        this.els.chromaR.value = parseInt(hex.slice(1, 3), 16);
                        this.els.chromaG.value = parseInt(hex.slice(3, 5), 16);
                        this.els.chromaB.value = parseInt(hex.slice(5, 7), 16);
                    }
                    this.applyImageAdjustments();
                };
            }

            const rgbHandler = () => {
                if (this.els.chromaR && this.els.chromaG && this.els.chromaB && this.els.colorPickerInput) {
                    const r = parseInt(this.els.chromaR.value).toString(16).padStart(2, '0');
                    const g = parseInt(this.els.chromaG.value).toString(16).padStart(2, '0');
                    const b = parseInt(this.els.chromaB.value).toString(16).padStart(2, '0');
                    this.els.colorPickerInput.value = `#${r}${g}${b}`;
                }
                this.applyImageAdjustments();
            };

            if (this.els.chromaR) this.els.chromaR.oninput = rgbHandler;
            if (this.els.chromaG) this.els.chromaG.oninput = rgbHandler;
            if (this.els.chromaB) this.els.chromaB.oninput = rgbHandler;

            if (this.els.anchorSelect) {
                this.els.anchorSelect.onchange = (e) => {
                    this.state.anchor = e.target.value;
                    this.refresh();
                };
            }

            this.sync(this.els.brightnessSlider, this.els.brightnessVal, 'brightness', true);
            this.sync(this.els.contrastSlider, this.els.contrastVal, 'contrast', true);
            this.sync(this.els.saturationSlider, this.els.saturationVal, 'saturation', true);

            // Transformation Buttons
            if (this.els.rotateBtn) {
                this.els.rotateBtn.onclick = () => {
                    this.state.adjustments.rotation = (this.state.adjustments.rotation + 90) % 360;
                    this.applyImageAdjustments();
                };
            }

            if (this.els.flipHBtn) {
                this.els.flipHBtn.onclick = () => {
                    this.state.adjustments.flipH = !this.state.adjustments.flipH;
                    this.applyImageAdjustments();
                };
            }

            if (this.els.flipVBtn) {
                this.els.flipVBtn.onclick = () => {
                    this.state.adjustments.flipV = !this.state.adjustments.flipV;
                    this.applyImageAdjustments();
                };
            }

            // Filter Buttons
            if (this.els.filterGrayscale) {
                this.els.filterGrayscale.onclick = () => {
                    this.state.filterGrayscale = !this.state.filterGrayscale;
                    this.applyImageAdjustments();
                };
            }

            if (this.els.filterInvert) {
                this.els.filterInvert.onclick = () => {
                    this.state.filterInvert = !this.state.filterInvert;
                    this.applyImageAdjustments();
                };
            }

            // Zoom Suite
            if (this.els.zoomBtn) this.els.zoomBtn.onclick = () => this.toggleFit();
            if (this.els.zoomSlider) this.els.zoomSlider.oninput = (e) => this.applyZoom(parseFloat(e.target.value));

            // Primary Actions
            if (this.els.generateBtn) this.els.generateBtn.onclick = () => this.captureVideo();
            if (this.els.downloadBtn) this.els.downloadBtn.onclick = () => this.exportProduction();
            if (this.els.autoDetectBtn) this.els.autoDetectBtn.onclick = () => this.triggerGridDetection(true);

            // Nudge Support
            document.querySelectorAll('.nudge-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const axis = e.currentTarget.dataset.axis;
                    const dir = parseInt(e.currentTarget.dataset.dir);

                    switch (axis) {
                        case 'x':
                            this.state.offsetX = Math.max(0, this.state.offsetX + dir);
                            this.els.offX.value = this.els.offXLabel.value = this.state.offsetX;
                            break;
                        case 'y':
                            this.state.offsetY = Math.max(0, this.state.offsetY + dir);
                            this.els.offY.value = this.els.offYLabel.value = this.state.offsetY;
                            break;
                        case 'f':
                            this.state.frameCount = Math.max(0, (this.state.frameCount || 0) + dir);
                            this.els.frameCountSlider.value = this.els.frameCountVal.value = this.state.frameCount;
                            break;
                    }
                    this.refresh();
                };
            });

            // Utils
            function id(name) { return document.getElementById(name); }
        }

        sync(slider, input, key, isAdjustment = false) {
            if (!slider || !input) return;
            slider.oninput = (e) => {
                input.value = e.target.value;
                if (isAdjustment) {
                    this.state.adjustments[key] = parseInt(e.target.value);
                    this.applyImageAdjustments();
                } else {
                    this.state[key] = parseInt(e.target.value);
                    this.refresh();
                }
            };
            input.oninput = (e) => {
                slider.value = e.target.value;
                if (isAdjustment) {
                    this.state.adjustments[key] = parseInt(e.target.value);
                    this.applyImageAdjustments();
                } else {
                    this.state[key] = parseInt(e.target.value);
                    this.refresh();
                }
            };
        }

        async handleFile(file) {
            if (!file) return;
            const type = file.type.startsWith('video/') ? 'video' : 'image';
            this.state.mediaType = type;
            this.state.mediaUrl = URL.createObjectURL(file);

            // Hide UI elements
            this.els.dropzone.style.display = 'none';
            this.els.canvasContainer.style.display = 'flex';

            // Reset visibility
            this.els.videoPreview.style.display = 'none';
            this.els.imagePreview.style.display = 'none';
            this.els.spritePreview.style.display = 'none';
            this.els.sourceCanvas.style.display = 'none';
            this.els.overlayCanvas.style.display = 'none';

            if (type === 'video') {
                this.setWorkflow('capture');
                this.els.videoPreview.src = this.state.mediaUrl;
                this.els.videoPreview.style.display = 'block';
                this.els.videoPreview.muted = true;
                this.els.videoPreview.play();
            } else {
                this.setWorkflow('studio');
                const img = await this.loadImage(this.state.mediaUrl);
                this.state.media = img;
                this.state.frameCount = 0; // Default
                this.setupStudio(img);
            }

            this.toggleFit(true); // Default to fit
        }

        loadImage(url) {
            return new Promise((res, rej) => {
                const img = new Image();
                img.onload = () => res(img);
                img.onerror = rej;
                img.src = url;
            });
        }

        setWorkflow(workflow) {
            this.state.workflow = workflow;
            // Manage Sidebar visibility
            this.els.capturePack.style.display = workflow === 'capture' ? 'block' : 'none';
            this.els.studioPack.style.display = workflow === 'studio' ? 'block' : 'none';
            this.els.adjustPack.classList.toggle('collapsed', workflow !== 'studio');
            this.els.pipContainer.style.display = workflow === 'studio' ? 'block' : 'none';
        }

        setStudioMode(mode) {
            this.state.mode = mode;
            this.els.modeGridBtn.classList.toggle('active', mode === 'grid');
            this.els.modeIslandBtn.classList.toggle('active', mode === 'island');
            this.els.gridControls.style.display = mode === 'grid' ? 'block' : 'none';
            this.els.islandControls.style.display = mode === 'island' ? 'block' : 'none';
            this.refresh();
        }

        setupStudio(img) {
            // Hide all preview elements
            this.els.videoPreview.style.display = 'none';
            this.els.imagePreview.style.display = 'none';
            this.els.spritePreview.style.display = 'none';

            this.els.sourceCanvas.width = img.width;
            this.els.sourceCanvas.height = img.height;
            this.els.overlayCanvas.width = img.width;
            this.els.overlayCanvas.height = img.height;

            const ctx = this.els.sourceCanvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            this.els.sourceCanvas.style.display = 'block';
            this.els.overlayCanvas.style.display = 'block';
            this.refresh();
        }

        toggleFit(forceFit = null) {
            this.state.fitMode = forceFit !== null ? forceFit : !this.state.fitMode;
            this.els.canvasContainer.classList.toggle('fit-mode', this.state.fitMode);
            this.els.zoomBtn.textContent = this.state.fitMode ? 'ðŸ” 1:1' : 'ðŸ” Fit';

            if (this.state.fitMode) {
                this.els.zoomSlider.value = 1;
                this.els.zoomVal.textContent = "Auto";
                this.els.canvasWrapper.style.transform = 'none';
            } else {
                this.applyZoom(1);
            }
        }

        applyZoom(val) {
            this.state.fitMode = false;
            this.state.zoom = val;
            this.els.canvasContainer.classList.remove('fit-mode');
            this.els.zoomSlider.value = val;
            this.els.zoomVal.textContent = Math.round(val * 100) + '%';
            this.els.zoomBtn.textContent = 'ðŸ” Fit';
            this.els.canvasWrapper.style.transform = `scale(${val})`;
        }

        refresh() {
            if (this.state.workflow !== 'studio') return;
            if (this.timers.refresh) clearTimeout(this.timers.refresh);
            this.timers.refresh = setTimeout(() => {
                this.calculateFrames();
                this.drawOverlays();
            }, 50);
        }

        async generateVideo() {
            if (!this.state.frames.length) return toast("No frames detected");
            this.els.progress.style.display = 'block'; this.els.generateBtn.disabled = true;
            try {
                const refined = await this.extractRefined();

                // Apply output scale
                const scale = this.state.outputScale / 100;
                const scaledWidth = Math.round(refined[0].width * scale);
                const scaledHeight = Math.round(refined[0].height * scale);

                const { blob, ext } = await this.createVideo(
                    refined,
                    scaledWidth,
                    scaledHeight,
                    this.state.videoFps,  // Use configured FPS  
                    this.state.videoQuality,
                    this.state.outputFormat,
                    this.state.customBitrate  // Pass custom bitrate
                );
                const url = URL.createObjectURL(blob);
                this.els.downloadBtn.onclick = () => {
                    const a = document.createElement('a'); a.href = url; a.download = `video_${Date.now()}.${ext}`; a.click();
                };
                this.els.downloadBtn.disabled = false; toast("Success!", "success");
            } catch (e) { toast(e.message); }
            finally { this.els.generateBtn.disabled = false; this.els.progress.style.display = 'none'; }
        }

        async extractRefined() {
            let maxW = 0, maxH = 0;
            this.state.frames.forEach(f => { maxW = Math.max(maxW, f.w); maxH = Math.max(maxH, f.h); });
            const size = Math.max(maxW, maxH) + this.state.exportPadding;
            return this.state.frames.map(f => {
                const cvs = document.createElement('canvas'); cvs.width = cvs.height = size;
                const ctx = cvs.getContext('2d');
                let dx = (size - f.w) / 2;
                let dy = this.state.anchor === 'center' ? (size - f.h) / 2 : (size - f.h);
                ctx.drawImage(this.state.img, f.x, f.y, f.w, f.h, dx, dy, f.w, f.h);
                return ctx.getImageData(0, 0, size, size);
            });
        }

        async createVideo(frames, w, h, fps, quality = 'high', format = 'webm', customBitrate = null) {
            const sw = Math.floor(w / 2) * 2, sh = Math.floor(h / 2) * 2;
            const cvs = document.createElement('canvas'); cvs.width = sw; cvs.height = sh;
            const ctx = cvs.getContext('2d');
            const stream = cvs.captureStream(fps);

            // Quality bitrate mapping
            const qualityMap = {
                'low': 500000,      // 500kbps
                'medium': 1500000,  // 1.5Mbps
                'high': 5000000,    // 5Mbps
                'lossless': 10000000 // 10Mbps+
            };
            // Use custom bitrate if provided, otherwise use quality preset
            const bitrate = customBitrate || qualityMap[quality] || 5000000;

            // Format and codec selection
            let type, ext;
            if (format === 'mp4' && MediaRecorder.isTypeSupported('video/mp4')) {
                type = 'video/mp4';
                ext = 'mp4';
            } else {
                type = 'video/webm;codecs=vp9';
                ext = 'webm';
            }

            const rec = new MediaRecorder(stream, { mimeType: type, videoBitsPerSecond: bitrate });
            const chunks = []; rec.ondataavailable = e => chunks.push(e.data);
            const blobP = new Promise(r => rec.onstop = () => r(new Blob(chunks, { type: type })));
            rec.start();

            const tcvs = document.createElement('canvas'); tcvs.width = w; tcvs.height = h;
            const tctx = tcvs.getContext('2d');
            const bar = this.els.progress.querySelector('.progress-bar');

            for (let i = 0; i < frames.length; i++) {
                tctx.putImageData(frames[i], 0, 0);
                ctx.clearRect(0, 0, sw, sh); ctx.drawImage(tcvs, 0, 0, w, h, 0, 0, sw, sh);
                if (bar) bar.style.width = (i / frames.length) * 100 + '%';
                await new Promise(r => setTimeout(r, 1000 / fps));
            }
            rec.stop();
            const blob = await blobP;
            return { blob, ext };
        }

        async triggerGridDetection(isManual = false) {
            if (!this.state.media) return toast("Load a sprite sheet first");
            if (isManual) {
                this.els.autoDetectBtn.disabled = true;
                this.els.autoDetectBtn.textContent = "ðŸ§  Analyzing...";
            }
            try {
                const base64 = this.els.sourceCanvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                const resp = await new Promise((res, rej) => {
                    google.script.run.withSuccessHandler(res).withFailureHandler(rej).detectGridFromNanoBananaPro(
                        base64,
                        this.state.media.width,
                        this.state.media.height,
                        this.state.rows,
                        this.state.cols
                    );
                });
                if (resp && resp.columns) {
                    const c = parseInt(resp.columns);
                    const r = parseInt(resp.rows);
                    this.state.cols = c; this.state.rows = r;
                    this.els.gridCols.value = c; this.els.gridRows.value = r;
                    this.els.colLabel.value = c; this.els.rowLabel.value = r;
                    this.setStudioMode('grid');
                    toast(`Detected ${c}x${r} Grid`, "success");
                }
            } catch (e) { console.error("Auto-detect failed: " + e.message); toast("Auto-detect failed"); }
            finally {
                if (isManual) {
                    this.els.autoDetectBtn.disabled = false;
                    this.els.autoDetectBtn.textContent = "ðŸ§  Auto-Detect Grid (AI)";
                }
                this.refresh();
            }
        }

        // Image Adjustment Functions
        applyImageAdjustments() {
            if (!this.state.media) return;

            if (this.timers.adjustment) clearTimeout(this.timers.adjustment);
            this.timers.adjustment = setTimeout(() => {
                const adj = this.state.adjustments;
                const img = this.state.media;
                const ctx = this.els.sourceCanvas.getContext('2d');

                // Handle rotation - adjust canvas size if needed
                const rotation = adj.rotation || 0;
                const isRotated90 = (rotation === 90 || rotation === 270);

                if (isRotated90) {
                    this.els.sourceCanvas.width = img.height;
                    this.els.sourceCanvas.height = img.width;
                    this.els.overlayCanvas.width = img.height;
                    this.els.overlayCanvas.height = img.width;
                } else {
                    this.els.sourceCanvas.width = img.width;
                    this.els.sourceCanvas.height = img.height;
                    this.els.overlayCanvas.width = img.width;
                    this.els.overlayCanvas.height = img.height;
                }

                // Clear and prepare
                ctx.clearRect(0, 0, this.els.sourceCanvas.width, this.els.sourceCanvas.height);

                // Apply transformations
                ctx.save();
                ctx.translate(this.els.sourceCanvas.width / 2, this.els.sourceCanvas.height / 2);

                if (rotation) {
                    ctx.rotate(rotation * Math.PI / 180);
                }

                const scaleX = adj.flipH ? -1 : 1;
                const scaleY = adj.flipV ? -1 : 1;
                ctx.scale(scaleX, scaleY);

                // Draw image centered
                ctx.drawImage(img, -img.width / 2, -img.height / 2);
                ctx.restore();

                // Get image data for pixel-level adjustments
                const imageData = ctx.getImageData(0, 0, this.els.sourceCanvas.width, this.els.sourceCanvas.height);
                let data = imageData.data;

                // 1. Background Removal Preview
                if (adj.removeBg && this.state.previewBgRemoval) {
                    const method = this.els.bgRemovalMethod ? this.els.bgRemovalMethod.value : 'smart';
                    const options = {
                        color: this.els.colorPickerInput ? this.els.colorPickerInput.value : '#00ff00',
                        tolerance: this.els.chromaTolerance ? parseInt(this.els.chromaTolerance.value) : 30,
                        threshold: this.els.alphaThreshold ? parseInt(this.els.alphaThreshold.value) : 128
                    };

                    const processedData = this.removeBackground(imageData, method, options);
                    // Update our local data reference to the processed pixels
                    for (let i = 0; i < data.length; i++) {
                        data[i] = processedData.data[i];
                    }
                }

                const brightness = adj.brightness || 0;
                const contrast = ((adj.contrast || 0) / 100) + 1;
                const saturation = ((adj.saturation || 0) / 100) + 1;

                // 2. Color & Filter Adjustments
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] === 0) continue; // Skip trans pixels

                    let r = data[i];
                    let g = data[i + 1];
                    let b = data[i + 2];

                    // Apply grayscale filter
                    if (this.state.filterGrayscale) {
                        const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
                        r = g = b = gray;
                    }

                    // Apply brightness
                    r += brightness;
                    g += brightness;
                    b += brightness;

                    // Apply contrast
                    r = ((r / 255 - 0.5) * contrast + 0.5) * 255;
                    g = ((g / 255 - 0.5) * contrast + 0.5) * 255;
                    b = ((b / 255 - 0.5) * contrast + 0.5) * 255;

                    // Apply saturation
                    const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
                    r = gray + (r - gray) * saturation;
                    g = gray + (g - gray) * saturation;
                    b = gray + (b - gray) * saturation;

                    // Apply invert filter
                    if (this.state.filterInvert) {
                        r = 255 - r;
                        g = 255 - g;
                        b = 255 - b;
                    }

                    // Clamp values
                    data[i] = Math.max(0, Math.min(255, r));
                    data[i + 1] = Math.max(0, Math.min(255, g));
                    data[i + 2] = Math.max(0, Math.min(255, b));
                }

                ctx.putImageData(imageData, 0, 0);
                this.refresh();
            }, 50);
        }

        applyFilter(filterType) {
            if (!this.state.img) return toast("No sprite sheet loaded");

            const ctx = this.els.sourceCanvas.getContext('2d');
            ctx.drawImage(this.state.img, 0, 0);

            const imageData = ctx.getImageData(0, 0, this.state.img.width, this.state.img.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                switch (filterType) {
                    case 'grayscale':
                        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                        data[i] = data[i + 1] = data[i + 2] = gray;
                        break;
                    case 'sepia':
                        data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
                        data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
                        data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
                        break;
                    case 'invert':
                        data[i] = 255 - r;
                        data[i + 1] = 255 - g;
                        data[i + 2] = 255 - b;
                        break;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Update the image
            this.state.img.src = this.els.sourceCanvas.toDataURL();
            toast(`${filterType} filter applied!`, "success");
        }

        resetImageAdjustments() {
            this.imageAdjustments = { brightness: 0, contrast: 0, saturation: 0 };
            this.els.brightnessSlider.value = this.els.brightnessVal.value = 0;
            this.els.contrastSlider.value = this.els.contrastVal.value = 0;
            this.els.saturationSlider.value = this.els.saturationVal.value = 0;

            if (!this.state.img) return;

            // Reload original image
            const ctx = this.els.sourceCanvas.getContext('2d');
            ctx.drawImage(this.state.img, 0, 0);
            this.refresh();
            toast("Adjustments reset!", "success");
        }

        rotateImage(degrees) {
            if (!this.state.img) return toast("No sprite sheet loaded");

            const canvas = this.els.sourceCanvas;
            const ctx = canvas.getContext('2d');

            // Swap dimensions for 90/270 degree rotations
            const newWidth = canvas.height;
            const newHeight = canvas.width;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = newWidth;
            tempCanvas.height = newHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Rotate
            tempCtx.translate(newWidth / 2, newHeight / 2);
            tempCtx.rotate((degrees * Math.PI) / 180);
            tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);

            // Update canvas
            canvas.width = newWidth;
            canvas.height = newHeight;
            ctx.drawImage(tempCanvas, 0, 0);

            // Update image
            this.state.img.src = canvas.toDataURL();
            toast(`Rotated ${degrees}Â°!`, "success");
        }

        flipImage(direction) {
            if (!this.state.img) return toast("No sprite sheet loaded");

            const canvas = this.els.sourceCanvas;
            const ctx = canvas.getContext('2d');

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Save current state
            tempCtx.drawImage(canvas, 0, 0);

            // Clear and flip
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            if (direction === 'horizontal') {
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
            } else {
                ctx.translate(0, canvas.height);
                ctx.scale(1, -1);
            }

            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();

            // Update image
            this.state.img.src = canvas.toDataURL();
            toast(`Flipped ${direction}!`, "success");
        }

        // Background Removal Algorithms
        removeBackground(imageData, method, options = {}) {
            switch (method) {
                case 'chroma':
                    return this.chromaKey(imageData, options.color, options.tolerance);
                case 'alpha':
                    return this.alphaThreshold(imageData, options.threshold);
                case 'smart':
                default:
                    return this.smartDetect(imageData);
            }
        }

        chromaKey(imageData, targetColorHex, tolerance) {
            // Convert hex to RGB
            const r = parseInt(targetColorHex.slice(1, 3), 16);
            const g = parseInt(targetColorHex.slice(3, 5), 16);
            const b = parseInt(targetColorHex.slice(5, 7), 16);

            const data = imageData.data;
            const thresh = (tolerance / 100) * 255; // Convert percentage to 0-255

            for (let i = 0; i < data.length; i += 4) {
                const pixelR = data[i];
                const pixelG = data[i + 1];
                const pixelB = data[i + 2];

                // Calculate color distance
                const distance = Math.sqrt(
                    Math.pow(pixelR - r, 2) +
                    Math.pow(pixelG - g, 2) +
                    Math.pow(pixelB - b, 2)
                );

                // If within tolerance, make transparent
                if (distance < thresh) {
                    data[i + 3] = 0; // Set alpha to 0
                }
            }

            return imageData;
        }

        alphaThreshold(imageData, threshold) {
            const data = imageData.data;

            for (let i = 3; i < data.length; i += 4) {
                // If alpha below threshold, make fully transparent
                if (data[i] < threshold) {
                    data[i] = 0;
                }
            }

            return imageData;
        }

        smartDetect(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            // Sample corner pixels to detect background color
            const samples = [];
            const sampleSize = 5;

            // Top-left corner
            for (let y = 0; y < sampleSize; y++) {
                for (let x = 0; x < sampleSize; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Calculate average background color
            const avgColor = samples.reduce((acc, s) => ({
                r: acc.r + s.r / samples.length,
                g: acc.g + s.g / samples.length,
                b: acc.b + s.b / samples.length
            }), { r: 0, g: 0, b: 0 });

            // Remove similar colors
            const tolerance = 30;

            for (let i = 0; i < data.length; i += 4) {
                const distance = Math.sqrt(
                    Math.pow(data[i] - avgColor.r, 2) +
                    Math.pow(data[i + 1] - avgColor.g, 2) +
                    Math.pow(data[i + 2] - avgColor.b, 2)
                );

                if (distance < tolerance) {
                    data[i + 3] = 0;
                }
            }

            return imageData;
        }

        calculateFrames() {
            if (!this.state.media && this.state.workflow !== 'studio') return;

            const rotation = this.state.adjustments ? (this.state.adjustments.rotation || 0) : 0;
            const target = `${this.state.mode}-${this.state.cols}-${this.state.rows}-${this.state.offsetX}-${this.state.offsetY}-${rotation}`;
            if (this.state.lastTarget === target) return;
            this.state.lastTarget = target;

            if (this.state.mode === 'grid') {
                const fw = Math.floor(this.els.sourceCanvas.width / this.state.cols);
                const fh = Math.floor(this.els.sourceCanvas.height / this.state.rows);
                if (fw <= 0 || fh <= 0) return;

                this.state.frames = [];
                for (let r = 0; r < this.state.rows; r++) {
                    for (let c = 0; c < this.state.cols; c++) {
                        const fx = this.state.offsetX + c * fw;
                        const fy = this.state.offsetY + r * fh;
                        if (fx + fw > this.els.sourceCanvas.width || fy + fh > this.els.sourceCanvas.height) continue;
                        this.state.frames.push({ x: fx, y: fy, w: fw, h: fh });
                    }
                }
                // Auto-trim: find last non-empty frame
                let lastValid = 0;
                for (let i = 0; i < this.state.frames.length; i++) {
                    if (!this.isFrameEmpty(this.state.frames[i])) {
                        lastValid = i + 1;
                    }
                }

                // Auto-update frame count boundary
                const total = this.state.frames.length;
                const finalCount = lastValid || total;

                if (!this.state.frameCount || this.state.frameCount > total || this.state.frameCount === total) {
                    this.state.frameCount = finalCount;
                }

                this.els.frameCountSlider.max = total;
                this.els.frameCountVal.max = total;
                this.els.frameCountSlider.value = this.state.frameCount;
                this.els.frameCountVal.value = this.state.frameCount;
            } else {
                this.calculateIslandFrames();
            }
        }

        async calculateIslandFrames() {
            const results = await this.findIslands(this.els.sourceCanvas, this.state.threshold);
            this.state.frames = results;

            // Auto-trim: find last non-empty frame
            let lastValid = 0;
            for (let i = 0; i < this.state.frames.length; i++) {
                if (!this.isFrameEmpty(this.state.frames[i])) {
                    lastValid = i + 1;
                }
            }

            const total = this.state.frames.length;
            const finalCount = lastValid || total;

            if (!this.state.frameCount || this.state.frameCount > total || this.state.frameCount === total) {
                this.state.frameCount = finalCount;
            }

            this.els.frameCountSlider.max = total;
            this.els.frameCountVal.max = total;
            this.els.frameCountSlider.value = this.state.frameCount;
            this.els.frameCountVal.value = this.state.frameCount;
            this.drawOverlays();
        }

        isFrameEmpty(f) {
            const ctx = this.els.sourceCanvas.getContext('2d');
            const data = ctx.getImageData(f.x, f.y, f.w, f.h).data;
            // Sample pixels to see if there's anything non-transparent
            for (let i = 3; i < data.length; i += 4) {
                if (data[i] > 10) return false; // Not empty if alpha > 10
            }
            return true;
        }

        async findIslands(canvas, threshold = 50) {
            const SCALE = 0.5;
            const w = Math.floor(canvas.width * SCALE), h = Math.floor(canvas.height * SCALE);
            const cvs = document.createElement('canvas'); cvs.width = w; cvs.height = h;
            const ctx = cvs.getContext('2d'); ctx.drawImage(canvas, 0, 0, w, h);
            const data = ctx.getImageData(0, 0, w, h).data;
            const visited = new Uint8Array(w * h);
            let islands = [];

            // Sample corner for BG (usually top-left)
            const bgR = data[0], bgG = data[1], bgB = data[2];
            const isBg = (i) => {
                if (data[i + 3] < threshold) return true;
                const d = Math.sqrt(Math.pow(data[i] - bgR, 2) + Math.pow(data[i + 1] - bgG, 2) + Math.pow(data[i + 2] - bgB, 2));
                return d < 30;
            };

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = y * w + x;
                    if (visited[idx] || isBg(idx * 4)) continue;
                    const island = { minX: x, maxX: x, minY: y, maxY: y };
                    const q = [[x, y]]; visited[idx] = 1;
                    let head = 0;
                    while (head < q.length) {
                        const [cx, cy] = q[head++];
                        if (cx < island.minX) island.minX = cx; if (cx > island.maxX) island.maxX = cx;
                        if (cy < island.minY) island.minY = cy; if (cy > island.maxY) island.maxY = cy;
                        for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
                            const nx = cx + dx, ny = cy + dy;
                            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                const nidx = ny * w + nx;
                                if (!visited[nidx] && !isBg(nidx * 4)) { visited[nidx] = 1; q.push([nx, ny]); }
                            }
                        }
                    }
                    if ((island.maxX - island.minX) > 4) {
                        islands.push({
                            x: island.minX / SCALE, y: island.minY / SCALE,
                            w: (island.maxX - island.minX + 1) / SCALE, h: (island.maxY - island.minY + 1) / SCALE
                        });
                    }
                }
            }
            return islands.sort((a, b) => (Math.floor(a.y / 50) - Math.floor(b.y / 50)) || (a.x - b.x));
        }

        drawOverlays() {
            const ctx = this.els.overlayCanvas.getContext('2d');
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            if (this.state.mode === 'grid') {
                ctx.fillStyle = '#ef4444';
                ctx.beginPath(); ctx.arc(this.state.offsetX, this.state.offsetY, 6, 0, Math.PI * 2); ctx.fill();
            }

            ctx.strokeStyle = '#f472b6'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
            this.state.frames.forEach(f => {
                ctx.strokeRect(f.x, f.y, f.w, f.h);
                ctx.fillStyle = '#06b6d4';
                let ax = f.x + f.w / 2;
                let ay = this.state.anchor === 'center' ? f.y + f.h / 2 : f.y + f.h;
                ctx.beginPath(); ctx.arc(ax, ay, 4, 0, Math.PI * 2); ctx.fill();
            });
        }

        startPipLoop() {
            let lastW = 0, lastH = 0;
            const loop = () => {
                if (this.state.workflow !== 'studio' || !this.state.frames.length) {
                    requestAnimationFrame(loop);
                    return;
                }

                const totalFrames = this.state.frameCount || 1;
                if (this.state.activeFrameIdx >= totalFrames) {
                    this.state.activeFrameIdx = 0;
                }

                const f = this.state.frames[this.state.activeFrameIdx];
                if (f) {
                    const ctx = this.els.pipCanvas.getContext('2d');
                    // Only resize if necessary to avoid flicker
                    if (ctx.canvas.width !== f.w || ctx.canvas.height !== f.h) {
                        ctx.canvas.width = f.w;
                        ctx.canvas.height = f.h;
                    }
                    ctx.clearRect(0, 0, f.w, f.h);
                    ctx.drawImage(this.els.sourceCanvas, f.x, f.y, f.w, f.h, 0, 0, f.w, f.h);
                }
                this.state.activeFrameIdx = (this.state.activeFrameIdx + 1) % totalFrames;
                setTimeout(() => requestAnimationFrame(loop), 100);
            };
            requestAnimationFrame(loop);
        }

        // Background Preview Functions
        showBackgroundPreview() {
            try {
                if (!this.state.img) return toast("No sprite sheet loaded");
                if (!this.els.removeBgToggle.checked) return toast("Enable 'Remove Background' first");

                // Create or get overlay
                if (!this.previewState.overlay) {
                    const overlay = document.createElement('div');
                    overlay.className = 'preview-overlay';
                    overlay.innerHTML = `
                        <canvas class="preview-canvas" id="preview-processed" style="opacity:1;"></canvas>
                        <canvas class="preview-canvas" id="preview-original" style="opacity:1;"></canvas>
                        <button class="preview-close-btn">Ã—</button>
                        <div class="comparison-slider">
                            <div style="text-align:center; color:white; margin-bottom:5px; font-weight:600; font-size:11px;">
                                Background Removal Strength: <span id="preview-percent">100</span>%
                            </div>
                            <input type="range" id="comparison-range" min="0" max="100" value="100" class="studio-slider">
                        </div>
                    `;
                    this.els.canvasContainer.appendChild(overlay);
                    this.previewState.overlay = overlay;
                    this.previewState.originalCanvas = overlay.querySelector('#preview-original');
                    this.previewState.processedCanvas = overlay.querySelector('#preview-processed');

                    // Close button
                    overlay.querySelector('.preview-close-btn').onclick = () => this.hidePreview();

                    // Comparison slider
                    const compSlider = overlay.querySelector('#comparison-range');
                    const percentLabel = overlay.querySelector('#preview-percent');
                    compSlider.oninput = (e) => {
                        const percent = parseInt(e.target.value);
                        percentLabel.textContent = percent;
                        this.updatePreviewComparison(percent);
                    };
                }

                // Get dimensions
                const width = this.state.img.width;
                const height = this.state.img.height;

                // Setup both canvases
                this.previewState.originalCanvas.width = width;
                this.previewState.originalCanvas.height = height;
                this.previewState.processedCanvas.width = width;
                this.previewState.processedCanvas.height = height;

                // Draw original to bottom canvas
                const origCtx = this.previewState.originalCanvas.getContext('2d');
                origCtx.drawImage(this.state.img, 0, 0);

                // Draw processed to top canvas
                const procCtx = this.previewState.processedCanvas.getContext('2d');
                procCtx.drawImage(this.state.img, 0, 0);

                // Apply background removal to processed canvas
                const imageData = procCtx.getImageData(0, 0, width, height);
                const method = this.els.bgRemovalMethod.value;

                const options = {};
                if (method === 'chroma') {
                    options.color = this.els.chromaColor.value;
                    options.tolerance = parseInt(this.els.bgTolerance.value);
                } else if (method === 'alpha') {
                    options.threshold = parseInt(this.els.alphaThreshold.value);
                }

                const processed = this.removeBackground(imageData, method, options);
                procCtx.putImageData(processed, 0, 0);

                // Show overlay
                this.previewState.overlay.classList.add('active');
                this.previewState.active = true;
                this.els.previewBgBtn.textContent = 'âŒ Close Preview';

                // Hide original canvas while preview is on
                if (this.els.canvasContainer) {
                    this.els.canvasContainer.classList.add('preview-active');
                }

                // Set initial to 100%
                this.updatePreviewComparison(100);

                toast("Use slider to see before/after!", "success");
            } catch (error) {
                toast(`Preview failed: ${error.message}`, "error");
                console.error(error);
            }
        }

        updatePreviewComparison(percent) {
            if (!this.previewState.originalCanvas) return;

            // Swap logic: 
            // 0% strength = 100% Original opacity (background visible)
            // 100% strength = 0% Original opacity (show Processed underneath - background removed)
            const opacity = 1 - (percent / 100);
            this.previewState.originalCanvas.style.opacity = opacity;
        }

        hidePreview() {
            if (this.previewState.overlay) {
                this.previewState.overlay.classList.remove('active');
                this.previewState.active = false;
                this.els.previewBgBtn.textContent = 'ðŸ‘ï¸ Preview Background Removal';

                // Show original canvas again
                if (this.els.canvasContainer) {
                    this.els.canvasContainer.classList.remove('preview-active');
                }
            }
        }

        downloadSpriteSheet() {
            if (!this.state.media) return toast("No sprite sheet loaded");

            try {
                // Apply output scale
                const scale = this.state.outputScale / 100;
                const scaledWidth = Math.round(this.state.img.width * scale);
                const scaledHeight = Math.round(this.state.img.height * scale);

                // Create scaled canvas
                const canvas = document.createElement('canvas');
                canvas.width = scaledWidth;
                canvas.height = scaledHeight;
                const ctx = canvas.getContext('2d');

                // Draw scaled image
                ctx.drawImage(this.state.img, 0, 0, scaledWidth, scaledHeight);

                // Apply background removal if enabled
                if (this.els.removeBgToggle.checked) {
                    const imageData = ctx.getImageData(0, 0, scaledWidth, scaledHeight);
                    const method = this.els.bgRemovalMethod.value;

                    const options = {};
                    if (method === 'chroma') {
                        options.color = this.els.chromaColor.value;
                        options.tolerance = parseInt(this.els.bgTolerance.value);
                    } else if (method === 'alpha') {
                        options.threshold = parseInt(this.els.alphaThreshold.value);
                    }

                    const processed = this.removeBackground(imageData, method, options);
                    ctx.putImageData(processed, 0, 0);
                }

                // Get format and quality settings
                const format = this.els.spriteExportFormat.value;
                const quality = parseFloat(this.els.spriteExportQuality.value);

                let mimeType, ext;
                if (format === 'webp') {
                    mimeType = 'image/webp';
                    ext = 'webp';
                } else if (format === 'jpeg') {
                    mimeType = 'image/jpeg';
                    ext = 'jpg';
                } else {
                    mimeType = 'image/png';
                    ext = 'png';
                }

                // Download
                const a = document.createElement('a');
                a.href = canvas.toDataURL(mimeType, quality);
                a.download = `sprite_sheet_${Date.now()}.${ext}`;
                a.click();

                toast("Sprite sheet downloaded!", "success");
            } catch (error) {
                toast(`Download failed: ${error.message}`, "error");
            }
        }


        async captureVideo() {
            console.log('[captureVideo] Called - Workflow:', this.state.workflow, 'VideoSrc:', this.els.videoPreview.src);
            if (this.state.workflow !== 'capture') {
                console.warn('[captureVideo] Blocked: workflow is not capture');
                toast('Please upload a video first');
                return;
            }
            if (!this.els.videoPreview.src) {
                console.warn('[captureVideo] Blocked: no video source');
                toast('No video loaded');
                return;
            }

            this.els.generateBtn.disabled = true;
            this.els.generateBtn.textContent = "âš¡ Processing...";

            try {
                const video = document.createElement('video');
                video.src = this.els.videoPreview.src;
                video.muted = true;
                await new Promise((res, rej) => {
                    video.onloadedmetadata = res;
                    video.onerror = rej;
                    setTimeout(() => rej(new Error("Timeout loading video")), 5000);
                });

                const interval = Math.max(1, parseInt(this.els.strideSlider.value));
                const frames = [];
                const vw = video.videoWidth;
                const vh = video.videoHeight;
                const duration = video.duration;
                const step = (interval / 30); // Approx 30fps base

                for (let t = 0; t < duration; t += step) {
                    video.currentTime = t;
                    await new Promise(r => video.onseeked = r);

                    const fcvs = document.createElement('canvas');
                    fcvs.width = vw; fcvs.height = vh;
                    fcvs.getContext('2d').drawImage(video, 0, 0);
                    frames.push(fcvs);

                    const pct = Math.floor((t / duration) * 100);
                    this.els.generateBtn.textContent = `âš¡ Capturing ${pct}%...`;
                    if (frames.length > 300) break; // Safety limit
                }

                if (!frames.length) throw new Error("No frames captured");

                // Layout onto master canvas
                const cols = Math.ceil(Math.sqrt(frames.length));
                const rows = Math.ceil(frames.length / cols);
                const scale = (parseInt(this.els.capScaleSlider?.value || 100)) / 100;
                const sw = Math.round(vw * scale);
                const sh = Math.round(vh * scale);

                const master = document.createElement('canvas');
                master.width = cols * sw;
                master.height = rows * sh;
                const mctx = master.getContext('2d');

                frames.forEach((f, i) => {
                    const x = (i % cols) * sw;
                    const y = Math.floor(i / cols) * sh;
                    mctx.drawImage(f, 0, 0, vw, vh, x, y, sw, sh);
                });

                // Transition to Studio
                const img = await this.loadImage(master.toDataURL('image/png'));
                this.state.media = img;
                this.state.cols = cols;
                this.state.rows = rows;
                this.state.frameCount = frames.length; // Store actual count
                this.els.gridCols.value = this.els.colLabel.value = cols;
                this.els.gridRows.value = this.els.rowLabel.value = rows;

                this.setWorkflow('studio');
                this.setupStudio(img);
                toast("Sequence Captured!", "success");

            } catch (err) {
                console.error(err);
                toast("Capture Failed: " + err.message);
            } finally {
                this.els.generateBtn.disabled = false;
                this.els.generateBtn.textContent = "âš¡ Generate Sprite Sheet";
            }
        }

        async exportProduction() {
            if (!this.state.media) return toast("Nothing to export");

            try {
                const canvas = document.createElement('canvas');
                canvas.width = this.els.sourceCanvas.width;
                canvas.height = this.els.sourceCanvas.height;
                const ctx = canvas.getContext('2d');

                // Draw base
                ctx.drawImage(this.els.sourceCanvas, 0, 0);

                // Background Removal if active
                if (this.state.adjustments.removeBg) {
                    const idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    // Use smart detection for export
                    const processed = this.smartDetect(idata);
                    ctx.putImageData(processed, 0, 0);
                }

                const format = this.els.exportFormat.value;
                const mime = `image/${format === 'jpg' ? 'jpeg' : format}`;
                const dataUrl = canvas.toDataURL(mime, 0.95);

                const link = document.createElement('a');
                link.download = `media_studio_export.${format}`;
                link.href = dataUrl;
                link.click();

                toast("Export Complete!", "success");
            } catch (err) {
                toast("Export Failed: " + err.message);
            }
        }
    }

    // Initialize everything after DOM is ready
    let studio;

    function toast(msg, type = 'error') {
        const d = document.createElement('div'); d.className = type + '-toast show'; d.textContent = msg;
        document.body.appendChild(d);
        setTimeout(() => { d.classList.remove('show'); setTimeout(() => d.remove(), 300); }, 3000);
    }

    // ==========================
    // DOM READY INITIALIZATION
    // ==========================
    document.addEventListener('DOMContentLoaded', () => {
        // Initialize Studio Engine
        studio = new MediaStudio();

        // Setup Collapsible Control Packs
        document.querySelectorAll('.control-pack').forEach(pack => {
            const header = pack.querySelector('.pack-header');
            if (header) {
                header.onclick = () => pack.classList.toggle('collapsed');
            }
        });
    });
</script>